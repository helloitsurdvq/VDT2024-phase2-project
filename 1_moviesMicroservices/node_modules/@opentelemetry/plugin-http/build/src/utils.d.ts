/// <reference types="node" />
import { Attributes, Span, Status } from '@opentelemetry/api';
import { ClientRequest, IncomingHttpHeaders, IncomingMessage, OutgoingHttpHeaders, RequestOptions, ServerResponse } from 'http';
import { Socket } from 'net';
import * as url from 'url';
import { Err, IgnoreMatcher, ParsedRequestOptions, SpecialHttpStatusCodeMapping } from './types';
/**
 * Specific header used by exporters to "mark" outgoing request to avoid creating
 * spans for request that export them which would create a infinite loop.
 */
export declare const OT_REQUEST_HEADER = "x-opentelemetry-outgoing-request";
export declare const HTTP_STATUS_SPECIAL_CASES: SpecialHttpStatusCodeMapping;
/**
 * Get an absolute url
 */
export declare const getAbsoluteUrl: (requestUrl: ParsedRequestOptions | null, headers: IncomingHttpHeaders | OutgoingHttpHeaders, fallbackProtocol?: string) => string;
/**
 * Parse status code from HTTP response. [More details](https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/data-http.md#status)
 */
export declare const parseResponseStatus: (statusCode: number) => Omit<Status, 'message'>;
/**
 * Returns whether the Expect header is on the given options object.
 * @param options Options for http.request.
 */
export declare const hasExpectHeader: (options: RequestOptions) => boolean;
/**
 * Check whether the given obj match pattern
 * @param constant e.g URL of request
 * @param obj obj to inspect
 * @param pattern Match pattern
 */
export declare const satisfiesPattern: <T>(constant: string, pattern: IgnoreMatcher) => boolean;
/**
 * Check whether the given request is ignored by configuration
 * It will not re-throw exceptions from `list` provided by the client
 * @param constant e.g URL of request
 * @param [list] List of ignore patterns
 * @param [onException] callback for doing something when an exception has
 *     occurred
 */
export declare const isIgnored: (constant: string, list?: IgnoreMatcher[] | undefined, onException?: ((error: Error) => void) | undefined) => boolean;
/**
 * Sets the span with the error passed in params
 * @param {Span} span the span that need to be set
 * @param {Error} error error that will be set to span
 * @param {(IncomingMessage | ClientRequest)} [obj] used for enriching the status by checking the statusCode.
 */
export declare const setSpanWithError: (span: Span, error: Err, obj?: IncomingMessage | ClientRequest | undefined) => void;
/**
 * Makes sure options is an url object
 * return an object with default value and parsed options
 * @param options original options for the request
 * @param [extraOptions] additional options for the request
 */
export declare const getRequestInfo: (options: url.URL | RequestOptions | string, extraOptions?: RequestOptions | undefined) => {
    origin: string;
    pathname: string;
    method: string;
    optionsParsed: RequestOptions;
};
/**
 * Makes sure options is of type string or object
 * @param options for the request
 */
export declare const isValidOptionsType: (options: unknown) => boolean;
/**
 * Check whether the given request should be ignored
 * Use case: Typically, exporter `SpanExporter` can use http module to send spans.
 * This will also generate spans (from the http-plugin) that will be sended through the exporter
 * and here we have loop.
 *
 * TODO: Refactor this logic when a solution is found in
 * https://github.com/open-telemetry/opentelemetry-specification/issues/530
 *
 *
 * @param {RequestOptions} options
 */
export declare const isOpenTelemetryRequest: (options: RequestOptions) => options is {
    headers: {};
} & RequestOptions;
/**
 * Returns outgoing request attributes scoped to the options passed to the request
 * @param {ParsedRequestOptions} requestOptions the same options used to make the request
 * @param {{ component: string, hostname: string }} options used to pass data needed to create attributes
 */
export declare const getOutgoingRequestAttributes: (requestOptions: ParsedRequestOptions, options: {
    component: string;
    hostname: string;
}) => Attributes;
/**
 * Returns attributes related to the kind of HTTP protocol used
 * @param {string} [kind] Kind of HTTP protocol used: "1.0", "1.1", "2", "SPDY" or "QUIC".
 */
export declare const getAttributesFromHttpKind: (kind?: string | undefined) => Attributes;
/**
 * Returns outgoing request attributes scoped to the response data
 * @param {IncomingMessage} response the response object
 * @param {{ hostname: string }} options used to pass data needed to create attributes
 */
export declare const getOutgoingRequestAttributesOnResponse: (response: IncomingMessage, options: {
    hostname: string;
}) => Attributes;
/**
 * Returns incoming request attributes scoped to the request data
 * @param {IncomingMessage} request the request object
 * @param {{ component: string, serverName?: string }} options used to pass data needed to create attributes
 */
export declare const getIncomingRequestAttributes: (request: IncomingMessage, options: {
    component: string;
    serverName?: string;
}) => Attributes;
/**
 * Returns incoming request attributes scoped to the response data
 * @param {(ServerResponse & { socket: Socket; })} response the response object
 */
export declare const getIncomingRequestAttributesOnResponse: (request: IncomingMessage & {
    __ot_middlewares?: string[];
}, response: ServerResponse & {
    socket: Socket;
}) => Attributes;
//# sourceMappingURL=utils.d.ts.map